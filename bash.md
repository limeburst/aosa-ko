# 3. Bourne-Again Shell

## 3.1. 서론

유닉스 셸은 사용자가 운영체제와 상호 작용하기 위한 명령 실행 인터페이스를 제공합니다. 하지만 셸은 풍부한 프로그래밍 언어이기도 합니다. 셸은 흐름 제어, 반복문, 조건문, 기본적인 연산, 기명 함수, 문자열 변수를 위한 구문 그리고 셸과 셸이 실행한 명령 간의 쌍방향 통신을 위한 구조를 제공합니다.

셸은 xterm 같은 터미널 에뮬레이터를 통해 대화식으로 사용하거나, 파일을 통해 명령을 읽는 비대화식으로 사용할 수 있습니다. Bash를 포함한 대부분의 현대적인 셸은 커맨드 라인을 입력하는 동시에 emacs나 vi의 키 바인딩을 사용해서 편집할 수 있으며, 실행하였던 명령들의 기록을 저장하여 다양한 형태로 제공합니다.

Bash의 데이터 처리 방식은 셸 파이프라인과 비슷합니다. 데이터는 터미널이나 스크립트를 통해 읽힌 후, 셸이 명령을 실행하고 반환 값을 받아 오게 될 때까지, 여러 단계의 변형 과정을 거칩니다.

이번 장에서는 bash의 입력 처리, 구문 분석, 단어 확장, 그리고 명령 실행까지의 구성 요소를 파이프라인의 관점에서 살펴볼 것입니다. 이러한 구성 요소들은 키보드나 파일로부터 데이터를 읽어 명령을 실행하기 위한 파이프라인의 역할을 합니다.

![Bash 구성 요소의 설계](http://aosabook.org/images/bash/bash-article-diagram.png)

### 3.1.1. Bash

Bash는 리눅스 커널 기반으로 구현된 GNU 운영체제와 OS X 등 몇몇 다른 통상적인 운영체제에 탑재된 셸입니다. Bash는 대화식 사용은 물론 프로그래밍 용도에서도 sh와 비교되는 개선사항들을 제공합니다.

Bash의 이름은 스티븐 본(현 유닉스 셸인 `/bin/sh`의, Bell Labs 유닉스 7판의 연구용 버전에서 처음 등장한, 직속 조상 프로그램의 개발자)의 이름과 재구현을 통한 재탄생의 개념을 합친 말장난인 Bourne-Again SHell의 두문자어입니다. Bash의 원저작자는 자유 소프트웨어 재단의 직원인 브라이언 폭스이며, 지금은 오하이오 클리블랜드에 있는 베이스 웨스턴 리저브 대학에서 자원봉사를 하는 제가 개발과 유지를 맡고 있습니다.

다른 GNU 소프트웨어처럼, bash는 꽤 포터블합니다. 현재 거의 모든 버전의 유닉스에서 작동하며, Cygwin이나 MinGW처럼 Windows 호스트 환경에서 자체적으로 이식한 버전이 존재하며, QNX와 Minix 같은 Unix-like 운영체제를 위해 이식된 버전도 함께 배포합니다. Microsoft's Services for Unix(SFU)에서 제공하는 환경처럼 Posix 환경만 있으면 빌드하고 실행할 수 있습니다.

## 3.2. 구문 단위와 기본형

### 3.2.1. 기본형

Bash에는 예약어, 단어, 연산자 세 종류의 토큰이 있습니다. 예약어는 `if`나 `while` 등의 흐름 제어 구문을 제공하기 위한, 셸과 셸 프로그래밍 언어에서 특별한 의미를 가지는 단어들입니다. 연산자들은 `|`와 `>` 처럼 셸에서 독립적으로 의미를 가지는 문자들이며, 하나 이상의 메타 문자로 이루어져 있습니다. 셸의 나머지 입력은 보통의 단어들로 이루어져 있으며, 그중 몇몇 단어들은 커맨드 라인에서 나타나는 위치에 따라 특별한 의미를 가지는 등, 특별한 대입문이나 숫자들입니다.

### 3.2.2. 변수와 매개 변수

다른 프로그래밍 언어들과 마찬가지로, 셸 역시 저장된 자료를 가리키고 관리하기 위한 변수를 제공합니다. 셸은 사용자가 설정 가능한 기본적인 변수와 매개 변수라고 불리는 내장 변수를 제공합니다. 매개 변수는 대부분의 경우 셸의 내부 상태 일부를 반영하며, 자동으로 설정되거나 다른 작업의 작용으로 설정됩니다.

변수의 값은 문자열입니다. 몇몇 값들은 문맥에 따라 특별하게 다뤄지는데, 이러한 값들에 대해서는 나중에 다뤄집니다. 변수들은 `name=value`의 형태로 지정됩니다. `value`는 선택적이며, 생략할 경우 `name`에 빈 문자열이 지정됩니다. 값이 지정된 경우 셸은 값을 확장해 `name`에 지정합니다. 셸은 변수의 설정 여부에 따라 다른 작업을 할 수 있지만, 변수를 설정하는 방법은 값을 지정하는 방법이 유일합니다. 값이 지정되지 않은 변수들은 선언되고 속성이 지정되어도 설정되지 않았다고 봅니다.

달러 기호로 시작하는 단어는 변수 또는 매개 변수 참조를 도입합니다. 달러 기호를 포함해서, 그 단어는, 기명 변수의 값으로 교체됩니다. 셸은 단순한 값 치환부터, 변숫값의 형식에 따라 변수 일부를 바꾸거나 변형시킬 수도 있는 풍부한 확장 연산자들을 제공합니다.

전역 변수와 지역 변수를 규정하는 방법들이 있습니다. 기본적으로 모든 변수는 전역 변수입니다. 어떠한 단순한 명령(익숙한 명령 종류를 예로 들자면, 명령 이름과 선택적인 매개 변수와 리다이렉션)도 대입문의 접두어를 붙여 해당 명령 안의 변수들을 그 명령 안에서만 존재하도록 할 수 있습니다. 셸은 함수에 대해 지역적인 변수를 가질 수 있는 저장된 프로시져, 즉 셸 함수를 구현합니다.

변수는 최소한의 타입을 가질 수 있습니다. 문자열 값을 가진 단순한 변수 외에도, 정수와 배열을 지정할 수 있습니다. 정수 타입의 변수들은 숫자로 취급됩니다. 이러한 변수에 문자열이 지정될 땐, 문자열은 수식으로 확장되어, 해당 수식의 결과가 변수의 값으로 지정됩니다. 배열은 첨자를 사용할 수도 있고 연관 관계를 사용할 수도 있습니다. 첨자 배열은 숫자를, 연관 배열은 문자열을 첨자로 사용합니다. 배열의 원소는 문자열이며, 필요한 경우 정수로 취급할 수도 있습니다. 배열의 원소는 또 다른 배열이 될 수 없습니다.

Bash는 셸 변수를 저장하기 위해 해시 테이블을, 변수 영역 구분을 위해 이 해시 테이블들의 연결 리스트를 사용합니다. 셸 함수 호출들을 위한 각각의 변수 영역과 명령 이전에 오는 대입문들을 위한 임시 변수 영역들이 있습니다. 예를 들어, 이러한 대입문들이 셸에 내장된 명령 이전에 오는 경우 셸은 변수 참조를 해석하는 올바른 순서를 기억하고 있어야 하며, 이때 연결된 리스트의 영역을 사용하게 됩니다. 실행 깊이에 따라 놀라울 정도로 많은 변수 영역들을 탐색해야 할 수도 있습니다.

### 3.2.3. 셸 프로그래밍 언어

대부분의 독자가 알만한 간단한 셸 명령은, `echo` 나 `ed`와 같은 명령 이름, 그리고 0개 이상의 매개 변수와 리다이렉션으로 이루어져 있습니다. 리다이렉션은 명령으로 주어지는 입력과 명령의 출력을 셸 사용자가 제어할 수 있게 합니다. 위에서 언급했던 것처럼, 사용자들은 이러한 간단한 명령에 지역 변수를 설정할 수 있습니다.

예약어는 조금 더 복잡한 셸 명령을 도입합니다. 여느 다른 고수준 프로그래밍 언어처럼 `if-then-else`, `while`, 값의 목록을 탐색하는 `for` 반복문, 그리고 C와 유사한 for loop 연산자 등의 구문이 있습니다. 이러한 명령들은 셸이 명령을 실행하거나, 조건의 만족 여부를 확인하여 그 결과에 따라 다른 작업을 하거나, 명령을 여러 번 실행할 수 있게 합니다. 

유닉스가 컴퓨팅 세계에 가져온 선물 중 하나는 파이프라인입니다. 파이프라인은, 목록 내의 한 명령의 출력이 그다음 명령의 입력이 되는, 명령의 선형 목록입니다. 모든 셸 구문은 파이프라인에서 사용될 수 있으며, 명령이 반복문에 데이터를 제공하는 것은 흔히 볼 수 있는 일입니다.

Bash는 어떤 명령의 표준 입력, 출력, 그리고 표준 에러 스트림을, 명령이 실행되었을 때 다른 파일이나 프로세스로 리다이렉트 시킬 수 있는 기능을 갖추고 있습니다. 또한, 셸 프로그래머들은 리다이렉션을 이용하여 현재 셸 환경에서 파일을 열거나 닫을 수 있습니다.  

Bash는, 셸 프로그램을 저장하여 여러 번 사용할 수 있게 합니다. 셸 함수와 스크립트들은 모두 명령의 집합에 이름을 주고 다른 여느 명령처럼 실행하는 방법입니다. 셸 함수는 특별한 구문으로 정의되며, 저장하여 같은 셸 문맥에서 실행됩니다. 셸 스크립트는 파일 내에 명령을 쓰고, 그 파일을 해석할 새로운 셸 인스턴스를 실행시킴으로써 생성됩니다. 셸 함수들은 대부분의 실행 문맥을 자신을 호출한 셸과 공유하지만, 셸 스크립트들은 새로운 셸을 호출하여 해석되기 때문에 환경 간 프로세스끼리 전달된 것들만 공유합니다.

### 3.2.4. 읽으면서

앞으로 이 장을 읽어 나가는 동안, 셸의 기능은 몇 가지 배열, 트리, 연결 리스트, 그리고 해시 테이블 등 몇 가지 자료구조만을 사용하여 구현된다는 사실을 염두에 두길 바랍니다. 거의 모든 셸의 구문들은 이러한 기본형들로 구현되어 있습니다.

셸은, 정보를 단계 간 옮기고, 각 단계에서 데이터 단위를 다루기 위해 `WORD_DESC` 이라는 자료 구조를 사용합니다. 

	typedef struct word_desc {
	  char *word;           /* 널 종료 문자열. */
	  int flags;            /* 이 단어와 연관된 플래그들. */
	} WORD_DESC;

매개 변수 목록과 같은 단어들은 간단한 연결 리스트로 합쳐집니다:

	typedef struct word_list {
	  struct word_list *next;
	  WORD_DESC *word;
	} WORD_LIST;

`WORD_LIST`는 셸 어디에서나 찾아볼 수 있을 정도로 많이 사용됩니다. 간단한 명령도 word list이며, 확장의 결과도 word list이며, 내장 명령어들도 매개 변수로 word list를 받습니다.

## 3.3. 입력 처리

Bash 처리 파이프라인의 첫 번째 단계는 파일이나 터미널로부터 문자열을 가져와, 줄 단위로 분리하고, 명령으로 변환시키기 위해 셸 구문 분석기에 넘겨주는 입력 처리입니다. 예상하셨듯이, 이 줄들은 개행 문자로 끝나는 문자열들의 서열입니다.

### 3.3.1. Readline과 커맨드 라인 편집

Bash는 대화식으로 작동할 땐 터미널로부터 입력을 받고, 그 외의 경우 매개 변수에 지정된 스크립트 파일을 입력으로 받습니다. 대화식으로 작동할 때 bash는 사용자가 커맨드 라인을 조작할 수 있게 하며, 사용자들에게 익숙한 유닉스 emacs나 vi 편집기와 비슷한 단축키와 편집 명령을 지원합니다.

Bash는 커맨드 라인 편집을 구현하기 위해 readline 라이브러리를 사용합니다. Readline은 커맨드 라인의 편집, 저장 그리고 불러오기와, csh와 유사한 방식의 히스토리 확장을 위한 함수들을 제공합니다. Bash는 readline의 주 사용자이며, 함께 개발되지만, readline에 bash에 특정한 코드는 없습니다. 다른 수많은 프로젝트도 터미널 기반 편집 인터페이스를 구현하기 위해 readline을 사용합니다.

Readline은 사용자들이 입력 서열을 길이 제한 없이 다양한 readline 명령에 바인딩할 수 있게 해주기도 합니다. 줄 위에서 커서를 옮기고, 문자를 입력하고 삭제하고, 이전 줄을 가져오고, 일부만 입력된 단어를 완성할 수 있는 명령도 제공합니다. 거기에다, 사용자들은 키 바인딩과 같은 구문을 사용해서, 입력 서열에 반응하여 입력되는 문자열인, 매크로를 정의할 수도 있습니다. 매크로는 readline 사용자들이 간편한 문자열 치환 및 약칭을 정의할 수 있게 도와줍니다.

#### Readline의 구조

Readline은 간단한 읽기, 발송, 실행, 화면 갱신의 반복 구조로 되어 있습니다. Readline은 `read`나 비슷한 기능의 함수를 사용하여 키보드로부터 문자열을 읽거나 매크로로부터의 입력을 받습니다. 각 문자열은 키맵이나 발송 테이블의 첨자로 사용됩니다. 키맵은 하나의 8bit 문자열을 인덱스로 가지지만, 키맵의 각 원소는 여러 가지가 될 수도 있습니다. 문자열들은 추가적인 키맵을 참조할 수 있으며, 다중 문자열 입력 서열이 가능한 이유입니다. `beginning-of-line` 같은 readline 명령으로 해석된 입력은 해당 명령을 실행시킵니다. `self-insert` 명령에 묶인 문자는 편집 버퍼에 추가됩니다. 문자열을 명령에 묶는 동시에 부분 문자열을 다른 명령에 묶을 수도 있습니다 (최근에 추가된 기능입니다). 이러한 동작을 할 것이라고 표시하는 키맵에 대응하는 특수한 인덱스가 있습니다. 문자열을 매크로에 바인딩하는 것은, 임의의 문자열을 명령줄에 추가하는 것부터, 복잡한 편집 수열을 생성하기 위한 단축키를 생성하는 것까지, 매우 큰 유연성을 제공합니다. Readline는 `self-insert`에 묶인 각 문자열을 편집 버퍼에 저장하며, 이 버퍼는 화면에 표시되었을 때 한 줄 이상의 공간을 차지할 수 있습니다.

Readline은 C `char` 버퍼와 문자열만 다루고, 필요하면 같은 타입을 사용하여 멀티바이트 문자열을 만듭니다. 성능과 저장 문제, 그리고 멀티바이트 문자열 지원이 널리 퍼지기 전에 편집 기능을 구현하는 코드가 있었기 때문에, 내부적으로 `wchar_t`를 사용하지 않습니다. 멀티바이트 문자열을 지원하는 로케일에서는 자동으로 멀티바이트 문자열을 그대로 편집 버퍼에 삽입합니다. 멀티바이트 문자열을 편집 명령에 바인딩할 수도 있지만, 입력 서열로서 바인딩해야 하며, 이것은 어렵고, 주로 원하는 결과를 가져오지 않습니다. 예를 들어, emacs와 vi 명령 집합에서도 멀티바이트 문자열은 사용하지 않습니다.

입력 서열이 마침내 편집 명령으로 해석되면, readline은 그 결과를 반영하도록 터미널 화면을 새로 고칩니다. 이 작업은 편집 명령이 문자열들을 버퍼에 삽입하거나, 편집 위치를 바꾸거나, 명령줄을 부분적이거나 전체적으로 바꾸는 것과 관계없이 실행됩니다. 히스토리 파일을 편집하는 명령 등, 어떤 바인딩 가능한 편집 명령들은 편집 버퍼의 내용에 아무런 변화를 만들지 않습니다.

터미널 화면을 새로 고치는 일은 단순해 보이지만, 사실은 꽤 복잡한 작업입니다. Readline은 지금 화면에 표시된 문자열들의 버퍼, 업데이트된 해당 버퍼의 내용 그리고 실제로 화면에 표시되는 문자열의 세 가지의 상태를 따라가야 합니다. 멀티바이트 문자열이 존재하는 경우 화면 갱신 엔진은 화면에 표시된 문자열들은 버퍼와 완벽히 일치하지 않는다는 점을 고려해야 합니다. 화면을 새로 고칠 때 readline은 현재 화면 버퍼의 내용과 업데이트된 버퍼의 차이점을 비교하여, 화면이 업데이트된 버퍼를 반영할 수 있는 가장 효율적인 편집 방법을 계산해야 합니다. 이 문제는 수년간 상당한 수의 연구 주제(string-to-string correction 문제)로 다루어졌습니다. 이 문제에 대해 readline은, 버퍼 간 차이가 발생하는 영역의 처음과 끝을 확인하고, 커서를 앞뒤로 옮기는 비용을 고려하여(문자열들을 삭제하는 명령을 호출하고 새로 쓰는 것과 화면의 내용을 덮어쓰는 것 중 어느 쪽이 더 싸게 먹힐까?) 해당 영역만을 갱신하는 비용을 계산하고, 최저 비용으로 화면을 갱신한 후, 필요한 경우 줄 끝에 남은 문자열들을 삭제하고 커서를 올바른 위치로 옮겨 마무리하는 접근 방식을 취합니다.

화면 갱신 엔진은 readline의 구성 요소 중 가장 자주 편집되는 부분 중 하나일 것입니다. 대부분의 변경점은 기능을 추가하기 위함이며, 특히 표시되지 않는 문자열들을 명령줄에 포함하는 기능(예를 들어, 색을 바꾸는 기능)과 멀티바이트 문자열을 처리하기 위한 기능이 상당수를 차지합니다.

Readline은 편집 버퍼를 자신을 호출한 프로그램에 전달하며, 변경되었을 수도 있는 버퍼의 이력을 기록하는 것은 해당 프로그램의 몫입니다.

#### Readline을 확장하는 프로그램

Readline이 사용자들에게 readline의 기본 작동 방식을 사용자하고 확장할 수 있는 다양한 수단을 제공하는 것처럼, 응용 프로그램들에도 readline의 기본적인 기능 집합을 확장할 수 있는 몇 가지 방법을 제공합니다. 첫 번째로, 바인딩 가능한 readline 함수들은, 표준적인 매개 변수 집합을 받아 특정된 결과를 전달할 수 있게 하여, 응용 프로그램들이 해당 프로그램 종속적인 함수로 readline을 확장하기 쉽게 해 줍니다. 예를 들어, Bash는 bash에 종속적인 단어 완성부터, 셸 내장 명령 인터페이스까지, 30가지 이상의 바인딩 가능한 함수를 더합니다.

응용 프로그램이 readline의 작동 방식을 변경할 수 있게 해주는 두 번째 방법은, 포인터를 광범위하게 사용하여, 함수를 잘 알려진 이름과 호출 인터페이스에 후킹할 수 있게 하는 것입니다. 응용 프로그램들은 readline의 일부를 교체하고, readline 앞에 기능을 끼워 넣거나, 응용 프로그램에 종속적인 변형을 가할 수 있습니다.

### 3.3.2. 비대화식 입력 처리

Readline을 사용하지 않을 때 셸은 `stdio`나 셸 자체의 버퍼링 된 입력 루틴을 사용하여 입력을 받습니다. 셸이 비대화식으로 동작할 때 Bash의 버퍼링 된 입력 패키지가 `stdio`에 비해 선호됩니다. 셸이 명령을 구문 분석하는 데 필요한 입력만 소비하고 나머지는 실행되는 프로그램을 위해 남기게 하는 Posix의 까다로운 제한 때문입니다. 셸이 표준 입력으로부터 스크립트를 읽을 때 특히 중요한데, 셸은 구문 분석기가 마지막으로 읽은 문자열 바로 앞으로 파일 오프셋을 되돌릴 수 있는 이상 원하는 만큼 입력을 버퍼링할 수 있습니다. 실용적인 관점에서 볼 때, 이것은 셸이 파이프 등 탐색 불가능한 장치로부터 읽을 때엔 스크립트들을 한 번에 문자열 하나씩만을 읽어야만 하지만, 파일을 읽을 때엔 원하는 만큼 문자열 버퍼링을 할 수 있다는 의미를 가집니다.

이런 특성은 제쳐놓고, 셸의 비대화식 입력 처리의 결과물은 개행문자로 끝나는 문자열 버퍼라는 점에서 readline과 같습니다.

### 3.3.3. 멀티바이트 문자열

멀티바이트 문자열 처리는 셸의 초기 구현이 생긴 지 한참 후에, 기존 코드에 미치는 영향을 최소화시키는 방향으로 추가되었습니다. 멀티바이트 문자열을 지원하는 로케일에서 셸은 입력을 바이트 버퍼(C `char`)에 저장하지만, 이 바이트 열이 멀티바이트 문자열일 수도 있다고 가정합니다. Readline은 (멀티바이트 문자열이 화면 영역을 얼마나 차지하고 있는지, 문자를 화면에 표시할 때 버퍼에서 읽어야 할 바이트 수를 알고 있는 것이 핵심인) 멀티바이트 문자열을 화면에 표시하는 방법, 줄 위에서 바이트 단위가 아니라 문자 단위로 왔다 갔다 하는 방법 등을 알고 있습니다. 그 외에는, 셸의 입력 처리에서는 멀티바이트 문자열은 별다른 영향을 미치지 않습니다. 이후에 다뤄질 셸의 다른 부분들에서는 멀티바이트 문자열을 인식할 수 있어야 하며, 입력 처리를 할 때 고려해야 합니다.

## 3.4. 구문 분석

구문 분석 엔진의 첫 번째 일은, 문자열 스트림을 단어로 나누고 결과에 의미를 부여하는 낱말 분석입니다. 낱말은 구문 분석기가 인식하는 가장 기본적인 단위입니다. 낱말은 메타 문자로 분리된 문자열이며, 메타 문자에는 공백이나 탭 등 단순한 구분자, 세미콜론, 앰퍼샌드 등 셸에서 특별한 의미를 지니는 문자들이 있습니다.

셸의 고질적인 문제는, 톰 더프가 Plan 9의 셸인 `rc`에 대한 논문에서 언급했던 것처럼, 아무도 Bourne 셸 문법을 모른다는 것입니다. Posix 셸 위원회는, 비록 문맥 의존성이 많지만, 유닉스 셸의 결정적인 문법을 발표했다는 점에서 공을 인정할 필요가 있습니다. 이 문법은 고전 Bourne 셸의 구문 분석기가 오류 없이 지원하던 구조를 지원하지 않는 등, 완벽하지는 않지만, 우리가 가진 가장 최선의 문법입니다.

Bash 구문 분석기는 초기 버전의 Posix 문법에서 기인하였으며, 제가 알기로 Yacc이나 Bison으로 구현된 유일한 Bourn 식의 구문 분석기입니다. Bash 구문 분석기에는 Bash 구문 분석기만의 문제점들이 있습니다. 셸 문법은 yacc 스타일의 구문 분석엔 적합하지 않으며, 복잡한 낱말 분석과, 구문 분석기와 낱말 분석기 간의 많은 협력이 필요합니다.

어쨌거나, 낱말 분석기는 readline이나 다른 곳으로부터 여러 줄의 입력을 받아, 메타 문자를 기준으로 토큰들로 분리하고, 토큰을 문맥에 따라 식별하여 구문 분석기가 선언문과 명령들로 구성할 수 있도록 전달합니다. 이 작업은 많은 문맥이 필요합니다. 예를 들어, 단어 for는 예약어, 식별자, 대입문의 일부, 또는 다른 단어일 수도 있습니다. 다음은 `for`를 표시하는 완벽히 유효한 명령입니다:

~~~
for for in for; do for=for; done; echo $for
~~~

이 시점에서, 별칭에 대한 이야기를 잠깐 할까 합니다. Bash는 단순한 명령의 첫 번째 단어를 별칭을 사용하여 임의의 문자열로 교체할 수 있게 합니다. 별칭은 완전한 단어이므로, 셸의 문법을 바꾸기 위해 사용(혹은 남용)될 수 있습니다. 별칭을 사용해 bash가 제공하지 않는 컴파운드 명령을 구현하는 것도 가능합니다. 구문 분석기가 언제 별칭을 확장할 수 있는지 낱말 분석기에 알려줘야 하지만, Bash 구문 분석기는 낱말 분석 단계에서의 별칭을 완벽히 구현합니다.

수많은 다른 프로그래밍 언어들처럼, 셸은 문자열의 특수한 의미를 없애기 위한 예외 문자의 사용을 허용하므로, `&` 등의 메타문자를 명령에 사용할 수 있습니다. 인용된 문자열의 해석이 조금씩 달라지는, 세 종류의 인용이 있습니다. 백슬래시는 다음에 오는 문자를 탈출시키며, 작은따옴표는 감싸는 모든 문자열의 해석을 방지하고, 큰따옴표는 몇 종류의 해석을 방지하지만 (백슬래시를 다르게 다루는 동시에) 특정 단어의 확장을 허용합니다. 낱말 분석기는 인용된 문자들과 문자열을 해석하고 구문 분석기가 예약어나 메타문자열로 해석하는 것을 방지합니다. 백슬래시로 탈출 된 문자열들을, ANSI C 문자열 같은 방식으로, 문자들이 표준 국제화 함수에 의해 번역될 수 있게 확장하는 두 가지 특수한 경우인 `$'…'` 과 `$"…"`이 있습니다. 전자는 널리 사용되지만, 후자는 용례가 별로 없어서 덜 사용됩니다.

구문 분석기와 낱말 분석기 간의 나머지 인터페이스는 간단합니다. 구문 분석기는 문법이 요구하는 상태 종속적인 분석을 위해 상태를 인코딩하여 낱말 분석기와 공유합니다. 예를 들어, 낱말 분석기는 토큰 타입에 따라, (적절한 문맥에서) 예약어, 단어, 대입문 등으로 단어를 분류합니다. 이를 위해 구문 분석기는 명령을 얼마나 분석하였는지, ("here-document"로도 불리는) 여러 줄로 이루어진 문자열을 분석하고 있는지, case 문이나 조건문을 분석하고 있는지, 아니면 확장된 셸 형태나 컴파운드 대입문을 분석하고 있는지에 대해 알려주어야 합니다.

구문 분석 단계에서, 명령어 치환의 끝을 알기 위한 작업 대부분은 하나의 함수(`parse_comsub`) 안에 있습니다. 이 함수는 셸 구문에 대해 불편할 정도로 많이 알고 있으며, 토큰을 읽어 들이는 코드의 많은 부분을 중복하여 가집니다. 이 함수는 here document, 셸 주석, 메타문자열, 단어 경계, 인용, 그리고 (`case`문에 있을 때 그 사실을 알기 위해)을 예약어를 언제 허용할지에 대한 정보를 알아야 합니다. 이 함수가 올바른 동작을 하게 만드는 데에는 굉장히 오랜 시간이 걸렸습니다.

단어 확장 도중에 명령어 치환이 일어날 경우, bash는 구조체의 정확한 끝을 알아내기 위해 구문 분석기를 사용합니다. 이것은 문자열을 `eval`을 위한 명령어로 바꾸는 작업과 비슷하지만, 명령이 문자열의 끝으로 끊기지는 않습니다. 이를 위해 구문 분석기는 오른쪽 괄호를 유효한 명령 종결자로 인식해야 하며, 이것은 낱말 분석기가 (올바른 문맥에서) 오른쪽 괄호를 EOF를 뜻하는 것으로 표시하기를 요구하며, 몇몇 생성 문법의 특이 상황을 만듭니다. 구문 분석기는, 또, 명령을 읽는 중 프롬프트 문자열 확장 도중 명령어 치환이 구문 분석되거나 실행될 수 있기 때문에, `yyparse`를 재귀적으로 호출하기 이전에 구문 분석기의 상태를 저장하고 복원시켜야 합니다. 입력 함수들이 미리 읽기를 구현하기 때문에, 이 함수는 bash가 입력을 문자열, 파일, 또는 readline을 통해 터미널로부터 읽던 bash 입력 포인터를 올바른 곳으로 되돌려야 합니다. 이것은 입력을 보존하기 위해서 뿐만이 아니라, 명령 치환 확장 함수가 실행할 정확한 문자열을 구성하기 위해서이기도 합니다.

프로그래밍 가능한, 단어 자동 완성으로 비슷한 문제가 야기됩니다. 다른 명령을 구문 분석하는 도중 임의의 명령을 실행할 수 있게 되는 문제 등이 있습니다. 이러한 문제들은 호출 주변에서 구문 분석기의 상태를 저장하고 복원시킴으로써 해결할 수 있습니다.

인용 역시, 상반되는 동작과 논쟁의 이유가 됩니다. 첫 Posix 셸 표준이 발행된 20년 후, 표준 심의회원들은 아직도 모호한 인용에 대한 적절한 작동 방식에 대해 논쟁하고 있습니다. 전과 같이, Bourne 셸은 작동 방식에 대해 관찰할 수 있는 레퍼런스 구현체로서의 가치만을 지닙니다.

구문 분석기는 명령을 의미하는 하나의 C 구조체를 반환하여(반복문 같은 컴파운드 명령의 경우엔 차례로 다른 명령들을 포함할 수 있습니다), 셸의 다음 작업 단계인, 단어 확장을 위해 넘겨줍니다. 명령 구조는 명령 객체와 단어의 목록으로 이루어져 있습니다. 대부분의 단어 목록은 문맥에 따라, 다음 장에서 설명될 변환들의 대상이 됩니다.

## 3.5. 단어 확장

구문 분석 단계와 실행 단계 사이에, 구문 분석 단계에서 생성된 여러 단어는, (예를 들어) `$OSTYPE`이 `"linux-gnu"`로 치환될 수 있도록, 한 번 또는 그 이상의 단어 확장 단계의 대상이 됩니다.

### 3.5.1. 매개변수와 변수 확장

변수 확장은 사용자들에게 가장 익숙한 확장입니다. 셸 변수들은 극소량의 타입을 사용하며, 몇 가지 예외를 제외하고는 대부분 문자열로 처리됩니다. 확장은 이러한 문자열들을 새로운 단어와 단어 목록으로 변환시킵니다.

변수의 값 자체에 대해 작용하는 확장들이 있습니다. 프로그래머들은 이러한 확장을 이용해 변수의 값, 길이의 부분 문자열을 만들거나, 특정한 형태에 맞는 부분을 제거, 교체, 또는 변수의 값 내의 알파벳들의 대소문자 간 변환을 할 수 있습니다.

변수의 상태에 따라 다르게 동작하는 확장들도 있습니다. 변수가 할당된 여부에 따라 서로 다른 확장이나 대입이 일어나게 할 수 있습니다. 예를 들어, `${parameter:-word}`는 지정되었을 경우 `parameter`로 확장되며, 그렇지 않거나 빈 문자열이 지정되었을 땐 `word`로 확장됩니다.

### 3.5.2. 그리고 더

Bash에는 다른 확장들도 많이 있으며, 각각의 까다로운 규칙을 가집니다. 처리 순서에서 가장 먼저 오는 확장은 중괄호 확장입니다.

    pre{one,two,three}post

를

    preonepost pretwopost prethreepost

로 확장합니다.

명령어 치환은 셸의 명령어 실행 기능과 변수 조작 기능의 혼합입니다. 명령어 치환으로, 셸은 명령을 실행하고, 출력을 받아, 해당 출력을 확장의 값으로 사용할 수 있습니다.

명령어 치환의 문제점 중 하나는, 감싼 명령어를 즉시 실행시켜 명령이 끝날 때까지 기다린다는 점이며, 따라서 셸이 명령에 입력을 보낼 수 있는 쉬운 방법이 없다는 것입니다. Bash는 이러한 결점을 보완하기 위해, 명령어 치환과 셸 파이프라인의 혼합인, 프로세스 치환이라는 기능을 사용합니다. 명령어 치환처럼 Bash는 명령어를 실행시키지만, 배경에서 실행시키므로 명령이 끝날 때까지 기다릴 필요가 없습니다. 프로세스 치환의 핵심은 bash가 명령에 대한 입출력 파이프를 만들고, 파이프를 확장의 결과가 될 파일명으로 노출하는 것입니다.

다음은 물결표 확장입니다. 기존엔 `~alan`을 앨런의 홈 디렉터리에 대한 참조로 변환시키려는 의도였지만, 몇 년 간 수많은 다른 디렉터리들에 대한 참조로도 사용할 수 있도록 확장되었습니다.

마지막으로, 수식 확장이 있습니다. `$((expression))`은 `expression`이 C 언어의 표현식과 같은 방식으로 해석되게 합니다. 표현식의 결과물이 확장의 결과가 됩니다.

변수 확장은 따옴표와 큰따옴표의 차이가 명백히 드러나는 곳입니다. 따옴표는 모든 확장을 억제합니다. 따옴표로 싸인 문자열들은 아무런 편집이 가해지지 않은 채로 확장 과정을 거치는 반면, 큰따옴표는 일부 확장은 허용하고 나머지는 억제합니다. 허용되는 확장에는 단어 확장과 명령, 수식, 그리고 프로세스 치환이 있습니다. 큰따옴표는 결과물이 다뤄지는 방식에만 영향을 미치지만, 중괄호와 물결표는 그렇지 않습니다.

### 3.5.3. 단어 분리

단어 확장의 결과물은 셸 변수 `IFS`에 있는 문자들을 구분자로 사용하여 분리됩니다. 이것은 셸이 하나의 단어를 그 이상의 단어들로 변환시키는 방식입니다. `$IFS`[^1]에 있는 문자 중 하나가 결과물에 나타날 때 마다, bash는 해당 단어를 두 개의 단어로 분리합니다. 따옴표나 큰따옴표는 단어 분리를 방지합니다.

### 3.5.4. 글로빙

결과물들이 분리된 후, 셸은 이전 확장의 결과물의 각 단어를 잠재적 패턴으로 해석하여, 앞에 붙은 디렉터리 경로를 포함하여, 존재하는 파일 이름들과 비교합니다.

### 3.5.5. 구현

셸의 기본적인 설계가 파이프라인에 대응된다면, 단어 확장은 그 자체로 작은 파이프라인입니다. 단어 확장의 각 단계는 단어를 받아, 필요한 변환을 가한 후, 다음 확장 단계에 전달합니다. 모든 단어 확장들이 수행되면 명령이 실행됩니다.

Bash의 단어 확장 구현은 위에서 설명된 기초 자료 구조를 기반으로 만들어졌습니다. 구문 분석기가 출력한 단어들은 개별적으로 확장되어, 각 입력 단어당 하나 이상의 단어를 만듭니다. `WORD_DESC` 자료 구조는 단어 하나에 대한 확장의 정보를 포함하는 데 충분히 유연한 것으로 확인되었습니다. 플래그들은 단어 확장 단계와 단계 간 정보 전달을 위해 사용되는 정보를 인코딩하기 위해 사용됩니다. 예를 들어, 구문 분석기는 플래그를 사용하여 확장과 명령 실행 단계에 특정 단어가 셸 대입문이라는 것을 알려주며, 단어 확장 코드는 단어 분리를 방지하거나 인용된 널 문자열(`$x`가 지정되지 않았거나 널 값을 가질 때의 `"$x"`)의 존재를 참고하기 위해 내부적으로 플래그를 사용합니다. 확장되는 단어마다, 추가적인 정보를 나타내기 위해 특정 문자열 인코딩을 사용하는, 하나의 문자로 이루어진 문자열을 사용했다면, 훨씬 더 힘들었을 것입니다. 구문 분석기와 마찬가지로, 단어 확장 코드 역시 1바이트 이상을 필요로 하는 문자열들을 다룹니다. 예를 들어, 변수 길이 확장(`${#variable}`)은 길이를 바이트가 아니라 문자 단위로 셉니다. 해당 작업을 위한 코드는, 멀티바이트 문자열이 존재하는 상태에서도, 확장이나 확장에 있어 특별한 의미를 가지는 문자열들의 끝을 정확히 판단할 수 있습니다.

## 3.6. 명령 실행

실질적인 동작은 Bash 내부 파이프라인의 명령 실행 단계에서 일어납니다. 대부분의 경우, 확장된 단어들은 명령의 이름과 매개 변수들로 분해됩니다. 그리고, `argv`를 이루게 되는 나머지 단어들과 함께 읽고 실행할 수 있는 파일로서 운영체제에 전달됩니다.

지금까지는 일부러 Posix에서 단순한 명령으로 불리는 명령 이름과 매개 변수의 집합을 가진 명령에 대한 설명에 초점을 맞췄습니다. 이 명령들은 가장 흔한 종류의 명령이지만, bash는 그 이상을 제공합니다.

명령 실행 단계의 입력은, 구문 분석기가 만든 명령 구조와 확장되었을 수도 있는 단어의 집합입니다. 이 단계는 bash 프로그래밍 언어가 빛을 발하는 곳입니다. Bash 프로그래밍 언어는 위에서 언급된 변수와 확장을 사용하여 고수준 언어에서 볼 수 있는 반복문, 변형, 그룹, 패턴 매칭을 기반으로 한 조건 실행문, 표현식 평가, 그리고 몇 가지 셸에 종속적인 고수준 구문 등의 구문들을 구현합니다.

### 3.6.1. 리다이렉션

운영체제의 인터페이스로서의 셸의 역할 반영 중 하나는 셸이 실행하는 명령의 입력과 출력을 리다이렉트 하는 기능입니다. 리다이렉션 구문은 셸의 초기 사용자들의 세련됨을 보여주는 것 중 하나입니다. 리다이렉션 구문은, 아주 최근까지, 사용하는 파일 서술자들을 사용자들이 직접 관리하고, 표준 입력, 출력 그리고 에러 이외의 것을 숫자로 명시적으로 지정할 것을 요구했습니다.

리다이렉션 문법에 최근에 추가된 것은, 사용자가 아니라 셸이 직접 적합한 파일 서술자를 고르고 지정된 변수에 할당시키게 하는 것입니다. 이것을 프로그래머가 파일 서술자들을 관리하는 것의 부담을 덜어주지만, 추가적인 처리가 필요합니다: 셸은 파일 서술자를 올바른 곳에 복사해야 하며, 특정 변수에 할당되어 있다는 것을 보장할 수 있어야 합니다. 이것은 낱말 분석기에서 구문 분석기, 그리고 명령 실행으로 정보가 전달되는 또 다른 예시입니다. 분석기는 단어를 변수 할당을 포함하는 리다이렉션으로 분류하고, 구문 분석기는 적절한 생성 문법의 문맥에서, 변수 할당이 필요하다는 것을 알리는 플래그를 가진 리다이렉션 객체를 만듭니다. 마지막으로, 리다이렉션 코드는 플래그를 해석하여 파일 서술자 번호가 올바른 변수에 할당되어 있는지 보장하게 됩니다.

리다이렉션을 구현하는 데에서 가장 어려운 부분은 리다이렉션을 취소하는 방법을 기억하는 것입니다. 셸은 새로운 프로세스를 생성하는 파일 시스템에서부터 실행된 명령들과 셸 자체적으로 실행하는 프로세스(빌트인)의 구분을 의도적으로 모호하게 합니다. 하지만 명령이 어떻게 구현되었든 간에, 리다이렉션의 효과는 명령이 끝난 이후에 남아있어선 안됩니다[^2]. 따라서 셸은 각 리다이렉션의 영향을 되돌리는 방법을 알고 있어야 하며, 그러지 못할 경우 셸 빌트인의 출력을 리다이렉트 하는 것은 셸의 표준 출력을 변경시키게 될 것입니다. Bash는 리다이렉션이 할당한 파일 서술자를 닫거나, 복사되는 파일 서술자를 저장하고 나중에 `dup2`을 사용하여 복원하는 등, 각 종류의 리다이렉션을 되돌리는 방법을 알고 있습니다. 이 작업들은 구문 분석기가 생성하는 것과 같은 리다이렉션 객체를 사용하며, 같은 함수들을 사용하여 처리됩니다.

다중 리다이렉션이 단순히 객체의 목록으로 구현되어 있기 때문에, 되돌리기를 위한 리다이렉션들은 별도의 목록에 저장하게 됩니다. 이 목록은 명령이 종료되었을 때 처리되지만, 셸 함수나 "`.`" 빌트인에 연결된 리다이렉션들은 해당 함수나 빌트인이 끝날 때까지 유효해야 하므로, 셸은 이 처리가 언제 일어나는지 대해 주의해야 합니다. 되돌리기를 위한 리다이렉션들이 명령을 실행시키지 않으면, `exec`와 연관된 리다이렉션들은 셸 환경에 보존되어 있기 때문에 `exec` 빌트인은 되돌리기 목록을 폐기합니다. 

또 다른 복잡함은 bash 스스로 짊어진 부담입니다. 고전 Bourne 셸은 사용자가 0번부터 9번까지의 파일 서술만을 조작할 수 있게 했으며, 10번 이상의 파일 서술자들은 셸 내부에서의 사용을 위해 예약하였습니다. Bash는 이 제한을 풀었으며, 사용자가 프로세스가 열 수 있는 파일의 한계치만큼의 서술자를 조작할 수 있게 하였습니다. 이것은 bash가 직접 열지 않은, 외부 라이브러리들이 연 파일 서술자들을 관리하고, 요청에 따라 서술자들을 이동시킬 수 있어야 한다는 의미를 가집니다. 이것은 close-on-exec 플래그가 관련되는 일부 휴리스틱, 그리고 명령이 실행되는 동안 관리되고 명령이 끝나면 폐기하거나 처리할 또 다른 리다이렉션의 목록이라는 많은 관리 부담을 만듭니다.

### 3.6.2. 빌트인 명령

Bash는 몇 가지 명령들을 셸 일부로 가집니다. 이 명령들은 새로운 프로세스를 만들지 않고 셸에 의해 실행됩니다.

명령을 빌트인으로 만드는 가장 흔한 이유는 셸의 내부 상태를 유지하거나 조작하기 위해서입니다. `cd`는 유닉스 입문 수업에서 `cd`가 외부 명령으로 구현될 수 없는 이유를 설명하기 위한 빌트인의 좋은 예시입니다.

Bash 빌트인들은 셸의 다른 부분과 같은 내부 기본형을 사용합니다. 각 빌트인은 단어의 목록을 매개 변수로 가지는 C 함수로 구현되어 있습니다. 이 단어들은 단어 확장 단계의 단어들이며, 빌트인들은 이 단어들을 명령 이름과 매개 변수로 취급합니다. 대부분의 경우, 빌트인들은 두 개의 예외를 제외하고는 다른 명령들에 적용되는 것과 같은 표준 확장 규칙이 적용됩니다. 대입문을 매개 변수로 받는 bash 빌트인들(`declare`, `export` 등)은 변수 할당에 사용하는 같은 확장 규칙이 적용됩니다. 이곳은 `WORD_DESC` 구조체의 `flags` 멤버가 셸의 내부 파이프라인의 단계 간 정보를 전달하기 위해 사용되는 곳입니다.

### 3.6.3. 단순한 명령의 실행

단순한 명령들은 가장 흔히 마주치게 되는 명령입니다. 파일 시스템으로부터 읽은 명령들의 검색과 실행, 그리고 반환값의 수집은 셸의 수많은 나머지 기능들을 포함합니다.

셸 변수 할당(`var=value` 형태의 단어)은 그 자체로 단순한 명령입니다. 대입문들은 커맨드 라인에서 명령 앞에 오거나 단독으로 존재할 수 있습니다. 대입문이 명령 앞에 올 땐, 변수들은 각자의 환경 내에서(빌트인 명령이나 셸 명령 앞에 올 땐, 몇 가지 예외를 제외하고는, 빌트인이나 함수가 실행되는 동안에는 영속됩니다), 실행된 명령에 전달됩니다. 그렇지 않을 때엔 대입문은 셸의 상태를 변경시킵니다.

셸 함수나 빌트인이 아닌 명령이 주어졌을 때, bash는 파일 시스템에서 그 명령의 이름을 가진 실행 파일을 검색합니다. `PATH` 변수는 쌍점으로 구분된, 검색할 디렉터리들을 가집니다. 사선(또는 다른 디렉터리 구분자)이 들어가 있는 명령들은 검색하지 않고 바로 실행됩니다.

명령이 `PATH` 검색을 통해 발견되면, bash는 명령 이름과 해당하는 절대 경로를 해시 테이블에 저장하고, 다음 `PATH` 검색에 참고합니다. 명령을 찾을 수 없는 경우, 특정 이름을 가진 함수가 정의되어 있는 경우, 명령 이름과 매개 변수들을 이 함수의 매개 변수로 넘겨 실행합니다. 일부 리눅스 배포판들은 찾을 수 없는 명령의 설치를 제안하기 위해 이 기능을 사용합니다.

Bash가 실행할 파일을 찾은 경우, 포크 후 새로운 실행 환경을 만들어 명령을 이 환경에서 실행시킵니다. 이 실행 환경은 시그널 처리와 리다이렉션에 의해 열리거나 닫힌 파일에 대한 사소한 수정 사항을 제외하고는 셸 환경의 완벽한 사본입니다.

### 3.6.4. 작업 제어

셸은 명령이 끝날 때까지 기다리다가 반환값을 수집하는 전경 실행과 바로 다음 명령을 읽는 배경 실행을 다룰 수 있습니다. 작업 제어는 프로세스들(실행되는 명령들)을 전경과 배경 간 전환하고, 프로세스들의 실행을 보류하고 재개할 수 있는 기능입니다. Bash는, 이것을 구현하기 위해, 본질적으로 하나 이상의 프로세스들로 실행되는 명령인, 작업이라는 개념을 도입합니다. 예를 들어, 파이프라인은 파이프라인의 각 요소당 하나의 프로세스를 사용합니다. 프로세스 그룹은 개별 프로세스들을 하나의 작업으로 합칠 수 있는 방식입니다. 터미널은 터미널에 연관된 프로세스 그룹 ID를 가지므로, 전경 프로세스 그룹은 터미널과 같은 프로세스 그룹 ID를 가진 그룹입니다. 

셸은 작업 제어를 구현하기 위해 몇 가지 간단한 자료 구조를 사용합니다. 프로세스 ID, 상태 그리고 종료되었을 때의 상황을 포함하는, 자식 프로세스를 나타내는 구조체가 있습니다. 파이프라인은 이러한 프로세스 구조들의 단순한 연결 리스트입니다. 작업은 이것과 비슷합니다. 프로세스 목록, 몇 가지 작업 상태(실행 중, 보류됨, 끝남 등), 그리고 작업의 프로세스 그룹 ID가 있습니다. 프로세스 목록은 주로 하나의 프로세스로만 이루어져 있습니다. 오직 파이프라인들만이 하나의 작업에 둘 이상의 프로세스가 연관되게 됩니다. 각 작업은 고유한 프로세스 그룹 ID를 가지며, 작업의 프로세스 그룹 ID와 같은 프로세스 ID를 가지는 프로세스는 프로세스 그룹 리더라고 불립니다. 현재 작업들의 집합은 배열에 저장되어 있으며, 사용자들에게 보이는 것과 개념적으로 매우 비슷합니다. 작업의 상태와 종료 상태 값들은, 작업을 이루는 프로세스들의 상태와 반환값들을 모아 만들어집니다.

셸의 다른 것과 비슷하게, 작업 제어의 구현에 있어 복잡한 부분은 작업 제어가 많은 관리를 요구한다는 것입니다. 셸은 프로세스들을 올바른 프로세스 그룹에 할당하고, 자식 프로세스 생성과 프로세스 그룹 할당이 동기적으로 일어나게 해야 합니다. 또, 터미널의 프로세스 그룹이 전경 작업을 결정하기 때문에 (셸의 프로세스 그룹으로 재설정되지 않으면, 셸은 터미널 입력을 읽을 수 없게 됩니다), 터미널의 프로세스 그룹이 올바르게 설정되어 있는지 확인해야 합니다. 작업 제어는 매우 프로세스 지향적이기 때문에, 반복문 통째로 하나의 단위로서 멈추고 재개시킬 수 있도록 while이나 for 반복문 같은 컴파운드 명령을 구현하는 것은 간단하지 않습니다. 그래서 이것을 구현하는 셸이 별로 없습니다.

### 3.6.5. 컴파운드 명령

컴파운드 명령은 하나 이상의 단순한 명령들로 이루어져 있으며, `if`나 `while` 등의 키워드로 도입됩니다. 컴파운드 명령은 셸 프로그래밍의 강력함을 가장 잘 나타내고 효과를 보이는 곳입니다.

컴파운드 명령의 구현은 딱히 놀랄 것이 못 됩니다. 구문 분석기는 컴파운드 명령에 대응하는 객체들을 만들고, 객체를 탐색하여 해석합니다. 각 컴파운드 명령은, 적절한 확장을 수행, 지정된 명령의 실행, 그리고 명령의 반환값에 따라 실행 흐름의 조작을 담당하는 C 함수에 의해 구현됩니다. `for` 명령을 구현하는 함수를 예로 들어 보겠습니다. 이 함수는 먼저 예약어인 `in` 다음에 오는 단어들을 확장합니다. 그리고 확장된 단어들을 각각 적절한 변수에 할당하고, `for` 명령 내의 명령들을 실행합니다. for 명령은 명령의 반환값에 따른 실행 조작을 하지 않아도 되지만, `break`와 `continue` 빌트인의 효과에 대해서는 주의해야 합니다. 목록에 있는 모든 단어가 사용되면 `for` 명령은 반환됩니다. 이것이 보여주는 것처럼, 대부분의 경우 구현은 설명과 매우 유사하게 동작합니다.

## 3.7. 얻은 교훈들

### 3.7.1. 내가 알아낸 것은 중요하다

저는 bash에 대한 작업을 20년 이상 해 왔으며, 몇 가지 사실을 발견했다고 생각합니다. 아무리 강조해도 충분하지 않은 제일 중요한 것은, 자세한 체인지로그는 필수적이라는 것입니다. 체인지로그를 확인해 특정 변경 사항에 대한 결정이 왜 일어났는지에 대해 상기할 수 있다는 것은 좋습니다. 해당 변경 사항을, 재현 가능한 테스트 케이스나 제안과 함께 있는 특정 버그 리포트에 연결할 수 있을 때 더욱더 좋습니다.

적절하다면, 프로젝트의 시작부터 포괄적인 회귀 테스트를 넣는 것을 추천하고 싶습니다. Bash엔 Bash의 사실상 모든 비대화적인 기능을 다루는 대한 수천 개의 테스트 케이스가 있습니다. 대화적인 기능에 대한 테스트도 만드는 것을 고려해 보았지만(Posix에 부합 테스트 모음이 있습니다), 테스트 모음이 필요로 하는 프레임워크를 배포하기 싫었습니다.

표준은 중요합니다. Bash는 표준 구현체로서의 혜택을 받았습니다. 당신이 구현하고 있는 소프트웨어의 표준화에 참여하는 것은 중요합니다. 소프트웨어의 기능과 동작에 대한 토론은 물론, 중재인으로서의 표준을 가지고 있는 것도 잘 동작할 수 있습니다. 물론, 표준에 따라, 형편없이 동작할 수도 있습니다.

외부 표준도 중요하지만, 내부 표준을 가지는 것 역시 좋습니다. 저는 설계와 구현에 대한 충분한 양의 훌륭하고 실용적인 조언을 받을 수 있는, GNU 프로젝트의 표준에 들어갔기에 운이 좋았습니다.

좋은 문서는 또 다른 필수 요소입니다. 어떤 프로그램이 다른 사용자에 의해 사용될 것으로 생각한다면, 포괄적이고 명확한 문서는 그만큼의 가치를 지닙니다. 소프트웨어가 성공적이면 많은 문서들이 생겨날 것이며, 해당 소프트웨어의 개발자가 권위 있는 문서를 작성하는 것이 중요합니다.

세상에는 수많은 좋은 소프트웨어들이 있습니다. 쓸 수 있는 것을 쓰십시오. 예를 들어, gnulib은 수많은 편리한 라이브러리 함수를 가지고 있습니다(gnulib에서 해당 함수들을 꺼내 쓸 수 있다는 전제하에). BSD와 Mac OS X도 마찬가지입니다. 피카소가 "위대한 예술가들은 훔친다."라는 말을 괜히 한 것이 아닙니다.

사용자 커뮤니티와 소통하는 동시에, 종종 있는 비판에 준비되어 있으십시오. 일부는 의문을 가지게 할 것입니다. 활성화된 사용자 커뮤니티는 매우 큰 도움이 될 수 있지만, 그것은 사용자들을 매우 감정적으로 만들기도 합니다. 그 감정들을 개인적으로 받아들이지는 마십시오.

### 3.7.2. 다르게 하고 싶었던 것들

Bash는 수백만 명의 사용자층을 가지고 있습니다. 저는 하위 호환성의 중요성에 대해서는 잘 알고 있습니다. 어떤 관점에서는, 하위 호환성은 미안해야 할 일이 없다는 것을 의미하기도 합니다. 하지만 세상은 그렇게 단순하지 않습니다. 종종 호환되지 않는 수정을 가해야 할 때가 있으며, 이런 변경점들의 대부분은 일부 사용자의 불만을 일으킵니다. 하지만 저는, 설계 실수를 고치기 위해서였든, 셸의 영역 간 호환되지 않는 부분을 고치기 위해서였든, 항상 이러한 결정을 한 타당한 이유가 있었다고 생각합니다. 좀 더 일찍 정식 bash 호환성 단계 비슷한 걸 만들어 놨었으면 합니다.

Bash의 개발 과정은 딱히 투명하진 않았습니다. 저는 마일스톤 릴리즈(bash-4.2 등)와, 개인이 릴리즈하는 패치의 개념에 익숙해져 있었습니다. 이렇게 한 이유가 있습니다. 자유 소프트웨어와 오픈 소스 세상보다 긴 릴리즈 타임라인을 가진 제조사들의 사정에도 맞춰 줘야 했으며, 과거에 원하던 것 이상으로 베타 버전의 소프트웨어가 광범위하게 확산하여 문제를 겪었던 적이 많았기 때문입니다. 하지만 새로 시작할 수 있다면, 공개 저장소를 사용하여 릴리즈를 좀 더 자주 하였을 것입니다.

이 목록에 구현에 대한 고려 사항이 없다면 허전할 것입니다. 여러 번 고려만 하고 실제로 하지 못했던 것 중 하나는, bash 구문 분석기를 `bison` 대신, 알기 쉬운 되부름 하향(recursive descent) 구문 분석 방식으로 다시 작성하는 것이었습니다. 한때는 명령 치환 기능을 Posix 표준에 맞추기 위해선 이런 작업이 필요할 줄 알았지만, 이렇게 큰 변경 사항을 만들지 않고서도 해낼 수 있었습니다. Bash를 처음부터 구현한다면, 직접 손으로 구문 분석기를 짰을 것입니다. 그랬다면 분명히 많은 것들이 쉬워졌을 것입니다.

## 3.8. 끝내며

Bash는 크고 복잡한 자유 소프트웨어의 좋은 예입니다. Bash는 20년 이상 개발되는 혜택을 받았으며, 성숙하고 강력합니다. 거의 모든 곳에서 작동하며, bash를 사용한다는 것을 인식하지 못하는 다수를 포함해, 매일 수백만 명의 사람들이 사용합니다. 

Bash는 스티븐 본이 작성한 7th Edition 유닉스 셸부터, 많은 기존 프로젝트들의 영향을 받았습니다. Bash에 가장 큰 영향은 미친 건 bash의 동작의 상당한 부분을 정의한 Posix 표준이었습니다. 이러한 하위 호환성과 표준 준수의 조합은 그 나름의 도전을 제시했습니다.

Bash는 GNU 프로젝트로서의 일부로서, bash가 존재하는 기반이 되는 동기와 체제를 얻었습니다. GNU 없인 bash도 없었을 것입니다. 또, bash는 적극적인 사용자 커뮤니티의 혜택도 얻었습니다. 사용자들의 의견은 지금까지의 bash를 만들어 왔으며, 자유 소프트웨어로서의 장점을 입증합니다.

## 각주

[^1]: 대부분의 경우, 이 중 한 문자의 서열.
[^2]: `exec` 빌트인은 이 규칙에 대한 예외입니다.
